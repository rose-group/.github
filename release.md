# 版本管理与发布流程文档

本文档旨在为项目团队提供一套标准的版本管理与发布流程，以确保发布的规范性、可追溯性和自动化。该流程适用于基于 Git 的项目，并在
GitHub 或 GitLab 平台上进行协作。

---

### 一、 版本管理模型深度解析

项目的版本管理模型是团队协作和发布流程的基石。选择合适的模型至关重要，因为它直接影响开发效率、发布频率和代码库的稳定性。本章将详细介绍两种在业界被广泛采用的主流模型，以帮助团队理解其背后的设计哲学和权衡。

#### 1.1 模型 A：主干开发 (Trunk-Based Development)

此模型是现代持续集成与持续部署 (CI/CD) 实践的核心，特别适合快速迭代、频繁发布的服务和应用。

* **核心哲学**:
    * **单一真相来源 (Single Source of Truth)**: `main` (或 `trunk`) 分支是所有开发的中心。所有开发者都直接从 `main`
      创建分支，并将短期存在的特性分支尽快合并回去。
    * **发布即标签 (Release is a Tag)**: `main` 分支的 HEAD 指针代表"下一个版本"的开发状态，其版本号通常是快照版 (e.g.,
      `1.3.0-SNAPSHOT`)。任何一个稳定、可发布的版本都通过在 `main` 分支的某个提交上创建一个 **Git 标签** (e.g., `v1.2.3`)
      来实现。这个标签才是不可变的、真正的发布记录。
* **工作流**:
    1. `main` 分支上的版本永远是快照版。CI 系统持续从 `main` 构建出快照构件供测试。
    2. 发布时，自动化脚本会在 `main` 分支上执行一个原子化或接近原子化的操作：
       a. 将版本从快照更新为正式版 (`1.2.3-SNAPSHOT` -> `1.2.3`) 并提交。
       b. 基于该提交创建 Git 标签 `v1.2.3`。
       c. 立即将版本更新为下一个快照版 (`1.2.4-SNAPSHOT`) 并提交。
    3. `main` 分支的开发从未中断，始终向前演进。
* **优点**:
    * **高开发效率**: 开发者无需在多个长期分支间切换，心智负担小。
    * **避免合并地狱**: 分支生命周期短，代码集成频率高，有效避免了长期分支带来的复杂合并问题。
    * **完美契合 CI/CD**: 持续将代码集成到主干，使得自动化测试和部署的价值最大化。
* **缺点**:
    * **对自动化要求高**: 需要强大的自动化测试和质量门禁来保证 `main` 分支的稳定性。
    * **`main` 分支非稳定**: 直接从 `main` 分支拉取的代码并非生产版本，可能对新成员造成困惑。
    * **热修复流程**: 修复线上问题 (`v1.2.3`) 需要从标签创建修复分支，修复后不仅要发布新标签 (`v1.2.4`)，还需将修复
      `cherry-pick` 到 `main` 分支。

#### 1.2 模型 B：GitFlow

GitFlow 是一个更加结构化、更严格的版本管理工作流，非常适合有明确发布周期、需要同时维护多个版本的项目（例如桌面应用、开源库）。

* **核心哲学**:
    * **职责分离 (Separation of Duties)**: 使用多个长期分支来明确分离不同的工作阶段。代码的稳定性随着其在分支间的流动而逐步提升。
    * **`main` 分支即生产 (Main is Production)**: `main` 分支极其稳定，其历史中的每一个提交都必须是一个可发布的生产版本。该分支的版本号永远是正式版。
* **分支角色**:
    * `main`: 生产分支。只接受来自 `release` 和 `hotfix` 分支的合并。
    * `develop`: 开发主干。所有新功能的集成点，版本为快照版。
    * `feature/*`: 从 `develop` 创建，用于开发新功能，最终合并回 `develop`。
    * `release/*`: 从 `develop` 创建，用于准备发布。在此分支上进行版本冻结、最终测试和 Bug 修复。
    * `hotfix/*`: 从 `main` 创建，用于紧急修复生产问题。
* **工作流**:
    1. 当 `develop` 分支积累了足够的功能后，创建一个 `release/1.3.0` 分支。
    2. 在该 `release` 分支上，将版本号更新为正式版 `1.3.0`，并进行严格的测试。
    3. 测试通过后，将 `release` 分支同时合并到 `main` (用于发布) 和 `develop` (确保开发主干同步)。
    4. 在 `main` 分支上为该合并提交打上标签 `v1.3.0`。
* **优点**:
    * **高稳定性**: `main` 分支受到严格保护，代码质量有保障。
    * **流程清晰**: 每个分支的角色和生命周期都非常明确，易于管理。
    * **并行开发与维护**: 可以方便地并行开发新功能 (`develop`) 和维护旧版本 (`hotfix` from `main`)。
* **缺点**:
    * **流程繁重**: 分支众多，合并操作频繁，增加了流程的复杂性。对于简单的项目或持续部署的场景，可能过于臃肿。
    * **工具依赖**: 常常需要特定的脚本或工具来简化其复杂的操作。

#### 1.3 模型 C：GitHub Flow

GitHub Flow 是一个极其简洁、轻量级的工作流，由 GitHub 推广，特别适合持续部署 (Continuous Deployment) 的项目。

* **核心哲学**:
    * **`main` 分支永远是可部署的 (deployable)**: 这是最高原则。任何时刻，`main` 分支的代码都应该可以被立即部署到生产环境。
    * **PR 即讨论 (Pull Request is a conversation)**: Pull Request 不仅是代码合并的请求，也是团队围绕一个特性进行讨论、审查和协作的核心场所。
    * **发布即合并 (Release is a Merge)**: 将一个 Pull Request 合并到 `main` 分支，即代表一次发布，并通常会触发自动部署。
* **分支角色**:
    * `main`: 唯一的长期分支，代表稳定且已部署或即将部署的代码。
    * `feature/*`: 从 `main` 创建，用于实现任何变更（新功能、Bug修复等）。它们是短期存在的，完成即合并。
* **工作流**:
    1. 从 `main` 创建一个描述性命名的特性分支。
    2. 在该分支上进行开发和提交。
    3. 当需要反馈或准备合并时，创建一个 Pull Request。
    4. 团队成员在 PR 中进行审查和讨论。
    5. 一旦 PR 被批准，就将其合并到 `main` 分支。
    6. 合并后的 `main` 分支将由自动化系统自动部署。
* **优点**:
    * **极其简单**: 只有 `main` 和特性分支，心智负担极小。
    * **持续交付友好**: 流程的设计天然地导向了小批量、高频率的发布和部署。
    * **清晰的责任**: 特性分支的所有权和进度非常清晰。
* **缺点**:
    * **不适合版本化发布**: 对于需要维护多个发布版本（如 `v1.0`, `v2.0`）的软件（例如开源库），此模型支持不足。
    * **对自动化部署要求高**: 它假设合并到 `main` 即可部署，这要求有非常可靠的自动化测试和部署流水线。
    * **生产环境风险**: 如果审查或测试不充分，有将 Bug 直接引入生产环境的风险。

在理解了上述模型后，本项目选择了一种 **GitHub Flow 的变体** 作为核心工作流程。该模型吸取了 GitHub Flow
的简洁与高效，同时引入了更明确的版本控制步骤（在特性分支内完成从快照到正式版的更新），以适应项目对版本化发布的需求。

* **核心思想**: **每一次向 `main` 分支的成功合并，都构成一次正式的发布**。这一思想通过以下关键实践得以实现：

---

### 二、 分支工作流程

本章详细描述项目中所使用的主要分支类型及其标准操作流程。

#### 2.1 特性分支流程 (Feature Branch Workflow)

特性分支是进行所有新功能开发和常规 Bug 修复的唯一方式。其生命周期构成了一次完整的发布。

**第 1 步：创建与初始化**

1. **从 `main` 创建分支**: 确保从最新的 `main` 分支创建特性分支。
   ```bash
   git checkout main
   git pull
   git checkout -b feature/new-user-profile
   ```
2. **更新为快照版本**: 在新分支上，立即将项目版本更新为下一个合适的**快照版本**。例如，如果 `main` 当前是 `1.2.3`，则新版本可以是
   `1.3.0-SNAPSHOT`。
    * *这一步明确了该分支正处于开发阶段，其产物不应被视为稳定版。*

**第 2 步：开发与迭代**

1. **编码**: 在该分支上进行所有相关的代码开发。
2. **提交**: 遵循提交信息规范，进行频繁、原子化的提交。
3. **持续集成**: CI/CD 系统会自动构建和测试此分支的快照版本。

**第 3 步：准备发布**
当功能开发完成并自测通过后，在特性分支内部执行以下发布准备步骤：

1. **与主干同步**: 将 `main` 分支的最新变更合并到特性分支，以解决任何潜在的冲突。
   ```bash
   git pull origin main
   ```
2. **更新为正式版本**: 将版本号从快照版（`1.3.0-SNAPSHOT`）更新为最终的**正式版本**（`1.3.0`）。
    * *在更新前，务必确认该版本号未被其他已合并的特性分支占用。*
3. **更新变更日志**: 自动或手动更新 `CHANGELOG.md` 文件。
4. **创建发布准备提交**: 将版本和变更日志的修改作为一个独立的提交，例如 `chore: release version 1.3.0`。

**第 4 步：发布**

1. **创建合并请求 (PR/MR)**: 从特性分支向 `main` 分支发起一个合并请求。
2. **代码审查**: 团队成员进行代码审查，重点关注代码逻辑、版本号正确性和变更日志的完整性。
3. **合并**: 审查通过后，将 PR 合并到 `main` 分支。**合并完成即代表新版本正式发布**。
4. **发布后操作 (自动化)**: 合并操作会自动触发 CI/CD 流程，执行以下任务：
    * **创建 Git 标签**：基于 `main` 分支的新合并提交，创建一个对应的 Git 标签（`v1.3.0`）并推送到远程。
    * **创建平台 Release 并上传构建**：在 GitHub/GitLab 上创建与该标签关联的 Release，并构建生产环境的构件（例如 Jar
      包）上传作为附件。
    * **构建并推送 Docker 镜像**: 基于新标签构建生产环境的 Docker 镜像，并将其推送到镜像仓库（例如 Docker Hub, GCR, ECR）。
    * **部署站点**: 触发独立的站点部署流程，将更新后的文档或应用站点发布到生产环境。

#### 2.2 热修复分支流程 (Hotfix Branch Workflow)

热修复分支专门用于修复线上生产环境的紧急 Bug。

1. **从 `main` 创建分支**: 从 `main` 分支的最新提交创建一个 `hotfix/*` 分支，例如 `hotfix/1.3.1`。
2. **更新版本**: 在该分支上，将版本更新为修复版本号，例如 `1.3.1`。
3. **紧急修复**: 进行必要的代码修复并提交。
4. **准备与发布**: 与特性分支流程类似，通过向 `main` 分支发起 PR 并合并来完成发布。
5. **自动化收尾**: 合并后，自动化流程同样会为该修复版本创建对应的 Git 标签和平台 Release。

---

### 三、 版本与提交规范

本章定义了项目必须遵守的版本号和 Git 提交信息的格式规范，这是实现自动化发布和维护清晰历史记录的基础。

#### 3.1 版本号规范

项目版本号严格遵循 **[语义化版本 2.0.0 (SemVer)](https://semver.org/spec/v2.0.0.html)** 规范，格式为 `MAJOR.MINOR.PATCH`。

* **`MAJOR` (主版本号)**: 当进行不兼容的 API 修改时增加。
* **`MINOR` (次版本号)**: 当以向后兼容的方式添加功能时增加。
* **`PATCH` (修订号)**: 当进行向后兼容的错误修复时增加。

在开发阶段（特性分支和热修复分支合并到 `main` 之前），版本号应带有 `-SNAPSHOT` 后缀，表示这是一个不稳定的开发版本。

**版本号决策实践指南:**

为保证版本号提升的一致性，团队成员可参考以下场景：

* **升级 `PATCH` (例如 `1.2.3` -> `1.2.4`)**:
    * 修复了一个不影响接口行为的内部 Bug。
    * 优化了现有算法或代码，提升了性能。
    * 更新了文档或注释。
    * 修复了构建脚本或 CI/CD 配置的问题。

* **升级 `MINOR` (例如 `1.2.3` -> `1.3.0`)**:
    * 增加了一个新的、向后兼容的 API 端点。
    * 为现有 API 增加了新的、可选的请求参数。
    * 为现有 API 的响应增加了新的字段。
    * 增加了一个完整的新功能模块，且不影响现有模块的兼容性。
    * *注意：升级 `MINOR` 版本时，`PATCH` 版本必须归零。*

* **升级 `MAJOR` (例如 `1.2.3` -> `2.0.0`)**:
    * 修改或删除了一个现有的 API 端点。
    * 修改了现有 API 的参数（例如，将可选参数变为必需）。
    * 修改了现有 API 的响应数据结构，导致客户端不兼容。
    * 引入了需要重构客户端代码的重大技术或架构变更。
    * *注意：升级 `MAJOR` 版本时，`MINOR` 和 `PATCH` 版本都必须归零。*

#### 3.2 提交信息规范

为了自动化生成变更日志 (Changelog) 并提高提交历史的可读性，所有提交信息都必须遵循 **[Conventional Commits](https://www.conventionalcommits.org/)** 规范。

**基本格式**: `<type>(<scope>): <subject>`，**`type`**: 用于说明提交的类别

| 图标 | 类型 | 说明 | 示例 |
|:---:|:-----------|:-----------------------|:---------------------------|
| ✨ | `feat` | 新功能 | `feat: 添加用户认证功能` |
| 🐛 | `fix` | 修复问题 | `fix: 修复登录验证失败问题` |
| 📝 | `docs` | 文档更新 | `docs: 更新 API 文档` |
| 🎨 | `style` | 代码格式 | `style: 格式化代码` |
| 🔨 | `refactor` | 代码重构 | `refactor: 重构认证模块` |
| ⚡️ | `perf` | 性能优化 | `perf: 优化查询性能` |
| ✅ | `test` | 测试相关 | `test: 添加单元测试` |
| 🧹 | `chore` | 构建/工具 | `chore: 更新依赖版本` |
| 🤖 | `ci` | CI/CD 相关 | `ci: 添加自动部署配置` |
| 📦 | `build` | 构建系统 | `build: 修改 Maven 配置` |
| ⬆️ | `deps` | 依赖更新 | `deps: 升级 Spring Boot 版本` |

**示例**:
*   `feat(api): add endpoint for user profile retrieval`
*   `fix(auth): correct password validation logic`
*   `chore: release version 1.3.0`

#### 3.3 分支命名规范

清晰的分支命名是高效协作的基础。所有分支都必须遵循以下规范：

* **格式**: `<type>/<short-description>`
* **`<type>`**:
    * `feature`: 用于开发新功能。
    * `fix`: 用于修复非紧急的常规 Bug（此场景也可使用 `feature`）。
    * `hotfix`: 用于修复生产环境的紧急 Bug。
    * `docs`: 用于撰写或修改文档。
    * `chore`: 用于处理与代码无关的琐事，如更新构建脚本。
* **`<short-description>`**:
    * 使用英文小写字母。
    * 单词之间用连字符 `-` 连接。
    * 简明扼要地描述分支的目的，例如关联的 Issue ID 或功能点。
* **示例**:
    * `feature/add-user-login-api`
    * `hotfix/fix-payment-timeout-issue-123`
    * `docs/update-readme-for-v2`

---

### 四、 合并请求 (Pull Request) 最佳实践

合并请求 (PR/MR) 是代码进入主干的唯一通道，也是团队进行代码审查、知识共享和质量控制的核心环节。遵循以下实践能显著提升协作效率。

#### 4.1 标题规范

*   PR 标题应遵循 **Conventional Commits** 格式，这使得从合并历史中也能清晰地看出每次发布的变更内容。
*   示例: `feat(api): add user profile endpoint`

#### 4.2 描述模板

建议使用一个 PR 描述模板，以确保信息完整。一个好的模板应包含：

*   **关联的 Issue**: 链接到项目管理工具中的相关任务或 Bug 报告（例如, `Resolves #45`）。
*   **变更摘要**: 简要说明此 PR 做了什么，解决了什么问题。
*   **实现细节**: （可选）对复杂的技术实现进行简要说明。
*   **测试方法**: 清晰地描述应如何测试此变更，包括手动测试步骤或自动化测试的范围。
*   **截图或录屏**: 对于涉及 UI/UX 的变更，附上截图或录屏是最高效的沟通方式。

#### 4.3 审查要求

*   **单一职责**: 尽可能保持 PR 的单一职责原则，一个 PR 只做一件事，这能让审查者更容易理解和评估变更。
*   **自审查**: 在发起 PR 前，作者应自己先完整地 review 一遍代码，检查是否有明显的错误或遗漏。
*   **指定审查者**: 至少需要指定一位或多位相关的同事进行审查。对于核心模块的变更，应指定该模块的负责人进行审查。
*   **建设性反馈**: 审查者应提供具体、有建设性的反馈，避免模糊不清的评论。讨论应聚焦于代码本身，对事不对人。
*   **禁止合并自己未经审查的 PR**: 除非是修复 CI 失败等极特殊情况，否则 PR 作者不应在未经他人审查批准的情况下自行合并。

---

### 五、 GitHub 与 GitLab 流程集成

这套发布流程可以与 GitHub Flow 或 GitLab Flow 无缝集成。

1. **日常开发**: 团队成员在各自的特性分支上工作，通过 PR/MR 将代码合并到 `main` 分支，CI/CD 流水线会对每次合并进行构建和测试。
2. **触发发布**: 当 `main` 分支达到一个可发布状态时，由团队中拥有发布权限的成员或通过自动化的 CI/CD Job 来执行上述发布流程。
3. **发布通知**: 在 GitHub/GitLab 上创建 Release 后，平台会自动通知关注此项目的用户，团队也可以通过其他渠道（如邮件、即时通讯工具）进行发布宣贯。 
